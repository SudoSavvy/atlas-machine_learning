#!/usr/bin/env python3
"""
Yolo class implementation.

This module contains the Yolo class for Darknet-based YOLO models. It includes methods
to load images, preprocess images, display images with bounding boxes, and predict objects
in images from a given folder.

The preprocessed images are resized to the specified input dimensions of the Darknet model
using inter-cubic interpolation and their pixel values are scaled to the range [0, 1].
Predictions (boxes, class indices, and box scores) are simulated here for demonstration.
In a real-world application, these would be generated by the model.

Usage:
    yolo = Yolo(model_path, classes_path, class_threshold, nms_threshold, anchors)
    predictions, image_paths = yolo.predict(folder_path)
    # Each element in predictions is a tuple: (boxes, box_classes, box_scores)
"""

import os
import cv2
import numpy as np


class Yolo:
    """
    Yolo class for Darknet-based YOLO models.
    
    Attributes:
        model_path (str): Path to the Darknet model file.
        classes_path (str): Path to the file containing class names.
        class_threshold (float): Threshold for class detection scores.
        nms_threshold (float): Threshold for non-max suppression.
        anchors (list): List of anchor boxes.
        class_names (list): List of class names loaded from classes_path.
        input_h (int): Expected input height for the Darknet model.
        input_w (int): Expected input width for the Darknet model.
    """

    def __init__(self, model_path, classes_path, class_threshold, nms_threshold, anchors):
        """
        Initialize a Yolo instance with the provided parameters.
        
        Default input dimensions (input_h and input_w) are set to 416.
        Class names are loaded from the given classes_path.
        
        Args:
            model_path (str): Path to the Darknet model file.
            classes_path (str): Path to the file containing class names.
            class_threshold (float): Threshold for class detection scores.
            nms_threshold (float): Threshold for non-max suppression.
            anchors (list): List of anchor boxes.
        """
        self.model_path = model_path
        self.classes_path = classes_path
        self.class_threshold = class_threshold
        self.nms_threshold = nms_threshold
        self.anchors = anchors

        # Set default input dimensions for the model
        self.input_h = 416
        self.input_w = 416

        # Load class names from the classes file, one per line
        with open(self.classes_path, 'r') as f:
            self.class_names = [line.strip() for line in f if line.strip()]

    def load_images(self, folder_path):
        """
        Loads images from the specified folder.
        
        Iterates through the given folder and loads each image file
        with a supported image extension.
        
        Args:
            folder_path (str): Path to the folder containing image files.
        
        Returns:
            tuple: (images, image_paths)
                - images (list of numpy.ndarray): The loaded images.
                - image_paths (list of str): The file paths corresponding to the images.
        """
        images = []
        image_paths = []
        valid_ext = {'.jpg', '.jpeg', '.png', '.bmp', '.tif', '.tiff'}

        for file in sorted(os.listdir(folder_path)):
            ext = os.path.splitext(file)[1].lower()
            if ext in valid_ext:
                full_path = os.path.join(folder_path, file)
                img = cv2.imread(full_path)
                if img is not None:
                    images.append(img)
                    image_paths.append(full_path)
        return images, image_paths

    def preprocess_images(self, images):
        """
        Preprocesses images for the Darknet model.
        
        For each image:
          - Records the original image dimensions.
          - Resizes the image to (input_h, input_w) using inter-cubic interpolation.
          - Scales pixel values from [0, 255] to [0, 1].
        
        Args:
            images (list of numpy.ndarray): List of images.
        
        Returns:
            tuple:
                - pimages (numpy.ndarray): Preprocessed images of shape
                  (ni, input_h, input_w, 3) where ni is the number of images.
                - image_shapes (numpy.ndarray): Original image sizes with shape (ni, 2)
                  for (height, width) of each image.
        """
        pimages = []
        image_shapes = []

        for img in images:
            image_shapes.append(img.shape[:2])
            resized = cv2.resize(img, (self.input_w, self.input_h), interpolation=cv2.INTER_CUBIC)
            resized = resized.astype(np.float32) / 255.0
            pimages.append(resized)

        pimages = np.array(pimages)
        image_shapes = np.array(image_shapes)
        return pimages, image_shapes

    def show_boxes(self, image, boxes, box_classes, box_scores, file_name):
        """
        Displays the image with boundary boxes, class names, and box scores.
        
        Each box is drawn with a blue line of thickness 2. Above each box,
        the class name and box score (rounded to 2 decimal places) are drawn in red,
        positioned 5 pixels above the top-left corner using FONT_HERSHEY_SIMPLEX,
        with font scale 0.5, line thickness 1, and LINE_AA for anti-aliasing.
        
        The image window is named according to file_name. If the 's' key is pressed,
        the image is saved in the 'detections' directory (created if necessary)
        with the same file name; any other key closes the window without saving.
        
        Args:
            image (numpy.ndarray): The original unprocessed image.
            boxes (numpy.ndarray): Array with bounding boxes (each as [x1, y1, x2, y2]).
            box_classes (numpy.ndarray): Array with class indices for each box.
            box_scores (numpy.ndarray): Array with detection scores for each box.
            file_name (str): The file name (without full path) used for the window title and saved file name.
        """
        img_display = image.copy()

        for box, class_idx, score in zip(boxes, box_classes, box_scores):
            top_left = (int(box[0]), int(box[1]))
            bottom_right = (int(box[2]), int(box[3]))
            cv2.rectangle(img_display, top_left, bottom_right, color=(255, 0, 0), thickness=2)
            if class_idx < len(self.class_names):
                label = f"{self.class_names[class_idx]} {score:.2f}"
            else:
                label = f"{class_idx} {score:.2f}"
            text_position = (top_left[0], max(top_left[1] - 5, 0))
            cv2.putText(
                img_display, label, text_position, cv2.FONT_HERSHEY_SIMPLEX,
                fontScale=0.5, color=(0, 0, 255), thickness=1, lineType=cv2.LINE_AA
            )

        cv2.imshow(file_name, img_display)
        key = cv2.waitKey(0) & 0xFF

        if key == ord('s'):
            os.makedirs('detections', exist_ok=True)
            save_path = os.path.join('detections', file_name)
            cv2.imwrite(save_path, img_display)
        cv2.destroyAllWindows()

    def predict(self, folder_path):
        """
        Predicts objects in all images found in the given folder.
        
        This method loads the images from the specified folder (using load_images), then
        generates predictions for each image. For demonstration purposes, dummy predictions
        (a single box, class index, and score) are generated. Each image is displayed using
        the show_boxes method with the window named after the image file name (without its full path).
        
        Args:
            folder_path (str): Path to the folder holding all the images to predict.
        
        Returns:
            tuple: (predictions, image_paths)
                - predictions (list): A list where each element is a tuple (boxes, box_classes, box_scores)
                  for the corresponding image.
                - image_paths (list): A list of image paths corresponding to each prediction.
        """
        # Load images and their paths
        images, image_paths = self.load_images(folder_path)
        predictions = []

        for image, full_path in zip(images, image_paths):
            # Simulate predictions for demonstration purposes.
            # In a real application, replace this dummy data with actual model predictions.
            boxes = np.array([[50, 50, 200, 200]])
            box_classes = np.array([0])
            box_scores = np.array([0.99])
            predictions.append((boxes, box_classes, box_scores))

            # Display the image using show_boxes.
            # The window name is the file name without the full path.
            file_name = os.path.basename(full_path)
            self.show_boxes(image, boxes, box_classes, box_scores, file_name)

        return predictions, image_paths


# Example usage (for testing purposes):
if __name__ == "__main__":
    # Define dummy anchors for testing purposes.
    anchors = [[10, 13, 16, 30, 33, 23]]
    
    # Create an instance of the Yolo class.
    yolo_instance = Yolo('test.h5', 'test.txt', 0.6, 0.5, anchors)

    # Predict objects on images located in the './yolo' folder.
    preds, paths = yolo_instance.predict('./yolo')
    
    # Output check: Print the number of predictions and image paths.
    print("Number of predictions:", len(preds))
    print("Image paths:", paths)
